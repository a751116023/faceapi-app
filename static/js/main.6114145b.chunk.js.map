{"version":3,"sources":["pages/setupFaceId/setupFaceId.module.css","redux/faceId/faceId.controller.js","redux/faceId/faceId.redux.js","redux/faceId/faceId.function.js","face.js","pages/faceApiVideoInput/faceApiVideoInput.js","pages/setupFaceId/setupFaceId.js","App.js","serviceWorker.js","redux/rootReducers.js","index.js","redux/storeConfig.js"],"names":["module","exports","getData","data","localStorage","getItem","saveData","JSON","parse","setItem","stringify","formatFaceIdData","descriptors","forEach","desc","push","formattedDescriptors","createFaceId","faceIds","id","uuid","name","date_created","Date","date_updated","updateFaceId","index","faceId","i","autodux","slice","initial","isLoading","error","activeDataId","actions","state","loadSuccess","setActiveDataId","reducer","getFaceIds","dispatch","callback","a","async","faceIdCtrl","err","faceIdActions","loadModels","MODEL_URL","process","faceapi","getFullFaceDescription","blob","inputSize","scoreThreshold","OPTION","useTinyModel","img","withFaceLandmarks","withFaceDescriptors","fullDesc","createMatcher","faceProfile","members","Object","keys","labeledDescriptors","map","member","descriptor","Float32Array","faceMatcher","FaceApiVideoInput","webcam","React","createRef","detections","match","facingMode","componentWillMount","setInputDevice","navigator","mediaDevices","enumerateDevices","then","devices","filter","device","kind","length","setState","exact","startCapture","interval","setInterval","capture","_setupMatcher","matcherProfile","props","current","getScreenshot","fd","detection","onReceiveDescriptors","findBestMatch","onReceiveMatch","prevProps","this","clearInterval","width","window","innerWidth","height","innerHeight","activeProfileLabel","videoConstraints","drawBox","_H","box","_W","_X","_x","_Y","_y","hasMatch","_label","_distance","bgColor","key","style","position","border","borderColor","transform","className","backgroundColor","marginTop","color","toFixed","display","flexDirection","alignItems","audio","ref","screenshotFormat","Component","SetupFaceId","recordDescriptors","booleans","isRecording","_toggleBoolean","_updateFaceId","activeFaceId","faceIdData","toString","setActiveFaceId","activeFaceData","nextMatcherProfile","canSetMatcherProfile","classes","wrapper","classnames","card_faceId","card_faceId_active","onClick","type","placeholder","value","onChange","e","target","disabled","indexOf","instruct","connect","faceIdReducer","faceIdFunctions","App","console","log","history","createHistory","basename","path","component","Boolean","location","hostname","combineReducers","store","initialState","composeEnhancers","__REDUX_DEVTOOLS_EXTENSION_COMPOSE__","compose","createStore","rootReducer","applyMiddleware","thunk","storeConfig","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"oGACAA,EAAOC,QAAU,CAAC,QAAU,6BAA6B,YAAc,iCAAiC,mBAAqB,wCAAwC,SAAW,gC,8XCG1KC,EAAU,WAEd,IAAIC,EAAOC,aAAaC,QAJX,sBAKb,OAAc,OAATF,GACHG,EAAW,IACJ,IAGAC,KAAKC,MAAQL,IAElBG,EAAW,SAAEH,GACjBC,aAAaK,QAbA,qBAakBF,KAAKG,UAAYP,KAWrCQ,EAAmB,SAAER,GAChC,GAAKA,EAAKS,YAAc,CACtB,IAAIA,EAAc,GAClBT,EAAKS,YAAYC,SAAU,SAAAC,GACzBF,EAAYG,KAAOR,KAAKC,MAAQM,OAElCX,EAAKa,qBAAuBJ,EAE9B,OAAOT,GAGIc,EAAe,WAC1B,IAAIC,EAAUhB,IACVC,EAAO,CACTgB,GAAIC,MACJC,KAAM,cACNT,YAAa,GACbU,aAAc,IAAIC,KAClBC,aAAc,IAAID,MAEpBL,EAAQH,KAAOZ,GACfG,EAAWY,IAGAO,EAAe,SAAEN,EAAIhB,GAChC,IAAIe,EAAUhB,IACdC,EAAKqB,aAAe,IAAID,KACxB,IAAIG,GAAS,EACbR,EAAQL,SAAU,SAAEc,EAAQC,GACrBD,EAAOR,KAAOA,IACjBO,EAAQE,MAEPF,GAAS,IACZR,EAASQ,GAAT,eACKR,EAASQ,GADd,GAEKvB,GAELG,EAAWY,K,UC1DXW,YAAU,CACZC,MAAO,SACPC,QAAS,CACPC,WAAW,EACXC,MAAO,KACP9B,KAAM,KACN+B,aAAc,MAEhBC,QAAS,CACPH,UAAW,SAAEI,EAAOJ,GAClB,OAAO,eACFI,EADL,CAEEJ,eAGJK,YAAa,SAAED,EAAOjC,GACpB,OAAO,eACFiC,EADL,CAEEjC,UAGJmC,gBAAiB,SAAEF,EAAOF,GACxB,OAAO,eACFE,EADL,CAEEF,qBA1BNK,E,EAAAA,QACAJ,E,EAAAA,QCDWK,EAAa,WACxB,OAAO,SAAAC,IFciB,SAAQC,GAAR,QAAAC,EAAAC,OAAA,iDACpB1B,EAAUhB,KACNW,SAAU,SAAAc,GAChBA,EAAShB,EAAmBgB,MAE9Be,EAAW,KAAMxB,GALO,qCEbtB2B,EAAwB,SAAEC,EAAK3C,GAC7BsC,EAAWM,EAAcV,YAAclC,S,0CCHtC,SAAe6C,IAAf,eAAAL,EAAAC,OAAA,uDACCK,EAAYC,sBADb,WAAAP,EAAA,MAECQ,IAAkCF,IAFnC,yBAAAN,EAAA,MAGCQ,IAAkCF,IAHnC,yBAAAN,EAAA,MAICQ,IAAiCF,IAJlC,qCAOA,SAAeG,EAAuBC,GAAtC,qCAAAV,EAAAC,OAAA,uDAA4CU,EAA5C,+BAAwD,IAEzDC,EAAiB,GACfC,EAAS,IAAIL,IAAgC,CACjDG,YACAC,mBAEIE,GAAe,EAPhB,WAAAd,EAAA,MAUWQ,IAAmBE,IAV9B,cAUDK,EAVC,kBAAAf,EAAA,MAcgBQ,IACHO,EAAKF,GACpBG,kBAAkBF,GAClBG,uBAjBE,cAcDC,EAdC,yBAkBEA,GAlBF,sCAsBA,SAAeC,EAAcC,GAA7B,mBAAApB,EAAAC,OAAA,uDAEDoB,EAAUC,OAAOC,KAAKH,GACtBI,EAAqBH,EAAQI,KAC/B,SAAAC,GAAM,OACJ,IAAIlB,IACFY,EAAYM,GAAQhD,KACpB0C,EAAYM,GAAQzD,YAAYwD,KAC9B,SAAAE,GAAU,OAAI,IAAIC,aAAaD,UAMnCE,EAAc,IAAIrB,IACpBgB,EAhB0B,IACvB,kBAkBEK,GAlBF,qCC5BP,IAwNeC,E,2MArNbC,OAASC,IAAMC,Y,EAEfxC,MAAQ,CACNyB,SAAU,KACVgB,WAAY,KACZjE,YAAa,KACb4D,YAAa,KACbM,MAAO,KACPC,WAAY,M,EAGdC,mBAAqB,oBAAArC,EAAAC,OAAA,kEAAAD,EAAA,MACbK,KADa,OAEnB,EAAKiC,iBAFc,sC,EAKrBA,eAAiB,WACfC,UAAUC,aAAaC,mBAAmBC,MAAK,SAAMC,GAAN,SAAA3C,EAAAC,OAAA,kEAAAD,EAAA,MACrB2C,EAAQC,QAC9B,SAAAC,GAAM,MAAoB,eAAhBA,EAAOC,SAF0B,mBAI7BC,OAAS,GAJoB,kCAAA/C,EAAA,MAKrC,EAAKgD,SAAS,CAClBZ,WAAY,UAN6B,iDAAApC,EAAA,MASrC,EAAKgD,SAAS,CAClBZ,WAAY,CAAEa,MAAO,kBAVoB,QAa7C,EAAKC,eAbwC,0C,EAiBjDA,aAAe,WACb,EAAKC,SAAWC,aAAc,WAC5B,EAAKC,YACJ,M,EAGLC,cAAgB,0BAAAtD,EAAAC,OAAA,qDAEZsD,EACE,EAAKC,MADPD,gBAFY,mCAOVA,EAPU,WAAAvD,EAAA,MAQSmB,EAAgBoC,IARzB,yBAOVA,eAPU,KAQV1B,YARU,WAMPmB,SANO,sD,EAqBhBK,QAAU,0BAAArD,EAAAC,OAAA,oDACJ,EAAK8B,OAAO0B,QADR,kCAAAzD,EAAA,MAEAS,EACJ,EAAKsB,OAAO0B,QAAQC,gBAnEV,KAqEVhB,MAAK,SAAAxB,GACL,GAAIA,EAAU,CACZ,IAAIgB,EAAahB,EAASO,KAAI,SAAAkC,GAAE,OAAIA,EAAGC,aACnC3F,EAAciD,EAASO,KAAI,SAAAkC,GAAE,OAAIA,EAAGhC,cAEnC,EAAK6B,MAAMK,sBACd,EAAKL,MAAMK,qBACT5F,EAAY8E,OAAS,EAAI9E,EAAc,MAI3C,EAAK+E,SAAS,CACZd,aACAjE,qBAlBA,WAuBF,EAAKwB,MAAMxB,cAAe,EAAKwB,MAAMoC,YAvBnC,kCAAA7B,EAAA,MAwBc,EAAKP,MAAMxB,YAAYwD,KAAI,SAAAE,GAAU,OACrD,EAAKlC,MAAMoC,YAAYiC,cAAcnC,OAzBnC,QAwBAQ,EAxBA,SA2BUA,EAAMY,OAAS,GACtB,EAAKS,MAAMO,gBACd,EAAKP,MAAMO,eAAiB5B,GAGhC,EAAKa,SAAW,CAAEb,UAhCd,sC,kFATW6B,GACdA,EAAUT,iBAAmBU,KAAKxE,MAAM8D,gBAC3CU,KAAKX,kB,6CAIPY,cAAcD,KAAKd,Y,+BAwCX,IAAD,EAKHc,KAAKT,MALF,IAELW,aAFK,MAEGC,OAAOC,WAFV,MAGLC,cAHK,MAGIF,OAAOG,YAHX,MAILC,0BAJK,MAIgB,KAJhB,IAOmCP,KAAKxE,MAAvCyC,EAPD,EAOCA,WAAYC,EAPb,EAOaA,MAAOC,EAPpB,EAOoBA,WACvBqC,EAAmB,KAEnBrC,IACFqC,EAAmB,CACjBN,MAAOA,EACPG,OAAQA,EACRlC,WAAYA,IAShB,IAAIsC,EAAU,KAuDd,OAtDIxC,IACFwC,EAAUxC,EAAWT,KAAI,SAACmC,EAAW3E,GACnC,IAAI0F,EAAKf,EAAUgB,IAAIN,OACnBO,EAAKjB,EAAUgB,IAAIT,MACnBW,EAAKlB,EAAUgB,IAAIG,GACnBC,EAAKpB,EAAUgB,IAAIK,GAEnBC,GAAW,EACV/C,GAASA,EAAMlD,KAClBiG,EACsB,YAApB/C,EAAMlD,GAAGkG,QACNhD,EAAMlD,GAAGmG,UAAY,KAEc,OAAvBZ,IACfU,EAAa/C,EAAMlD,GAAGkG,SAAWX,GAGrC,IAAIa,EAAUH,EAAW,QAAU,OAEnC,OACE,yBAAKI,IAAKrG,GACR,yBACEsG,MAAO,CACLC,SAAU,WACVC,OAAQ,QACRC,YAAaL,EACbf,OAAQK,EACRR,MAAOU,EACPc,UAAU,aAAD,OAAeb,EAAf,cAAuBE,EAAvB,SAGVE,EACC,yBACEU,UAAU,oDACVL,MAAO,CACLM,gBAAiBR,EACjBI,OAAQ,QACRC,YAAaL,EACblB,MAAOU,EACPiB,UAAW,EACXC,MAAO,OACPJ,UAAU,kBAAD,OAAoBhB,EAApB,SAGX,8BAAOxC,EAAMlD,GAAGkG,QAChB,8BAAOhD,EAAMlD,GAAGmG,UAAUY,QAAU,KAEpC,WAQZ,yBACEJ,UAAU,SACVL,MAAO,CACLU,QAAS,OACTC,cAAe,SACfC,WAAY,WAId,yBACEZ,MAAO,CACLpB,MAAOA,EACPG,OAAQA,IAGV,yBAAKiB,MAAO,CAAEC,SAAU,WAAYrB,MAAOA,IACxCM,EACC,yBAAKc,MAAO,CAAEC,SAAU,aACtB,kBAAC,IAAD,CACEY,OAAO,EACPjC,MAAOA,EACPG,OAAQA,EACR+B,IAAKpC,KAAKlC,OACVuE,iBAAiB,aACjB7B,iBAAkBA,KAGpB,KACHC,GAAoB,Y,GA9MD6B,aCK1BC,E,2MACJvI,YAAc,K,EACdwI,kBAAoB,K,EAEpBhH,MAAQ,CACNiH,SAAU,CACRC,aAAa,I,EAIjBC,eAAiB,SAAEtB,GACjB,IAAIoB,EAAQ,eAAQ,EAAKjH,MAAMiH,UAC/BA,EAAUpB,IAASoB,EAAUpB,GAC7B,EAAKtC,SAAW,CACd0D,c,EAIJG,cAAgB,WAAO,IAcmC,EAdpC,EAKhB,EAAKrD,MAHPjF,EAFkB,EAElBA,QACAuI,EAHkB,EAGlBA,aACAhI,EAJkB,EAIlBA,aAGEiI,EAAa,MACjBxI,EAAQL,SAAU,SAAAc,GACXA,EAAOR,KAAOsI,IACjBC,EAAa/H,MAIG,OAAf+H,GAA4C,OAArB,EAAK9I,cAC/Ba,EAAegI,EAAc,CAC3B7I,YAAY,GAAD,6BACJ8I,EAAW9I,mBADP,QACsB,IADtB,YAEL,EAAKA,YAAY+I,WAFZ,U,mFAQK,IAAD,EAIf/C,KAAKT,MAFPjF,EAFiB,EAEjBA,QACAsB,EAHiB,EAGjBA,WAGe,OAAZtB,GACHsB,M,+BAGO,IAAD,OAGJ8G,EAEA1C,KAAKxE,MAHPiH,SACEC,YAHI,EAaJ1C,KAAKT,MALPjF,EARM,EAQNA,QACAuI,EATM,EASNA,aACAG,EAVM,EAUNA,gBACA3I,EAXM,EAWNA,aACAQ,EAZM,EAYNA,aAGEoI,EAAiB,KAChBJ,GAAgBvI,GACnBA,EAAQL,SAAU,SAAAV,GACXA,EAAKgB,KAAOsI,IACfI,EAAiB1J,MAIvB,IAAI+F,EAAiB,KACrB,GAAiB,OAAZhF,EAAmB,CACtB,IAAI4I,EAAqB,GACrBC,GAAuB,EAC3B7I,EAAQL,SAAU,SAAEc,EAAQD,GACrBC,EAAOX,sBAAwBW,EAAOX,qBAAqB0E,OAAS,IACvEoE,EAAmB,QAAD,OAAUpI,IAAY,CACtCL,KAAMM,EAAON,KACbT,YAAae,EAAOX,sBAEtB+I,GAAuB,MAGtBA,IACH7D,EAAiB4D,GAGrB,OACE,yBAAKvB,UAAWyB,IAAQC,SActB,gDACA,6BACA,yBAAK1B,UAAU,iBACb,yBAAKA,UAAU,qBACb,wBAAIA,UAAU,QAAd,qBACCrH,GAAWA,EAAQkD,KAAM,WAIvB1C,GAAY,IAHbP,EAGY,EAHZA,GACAE,EAEY,EAFZA,KACAT,EACY,EADZA,YAEA,OACE,yBACEqH,IAAKvG,EACL6G,UAAW2B,IACTF,IAAQG,YACRV,IAAiBtI,EAAK6I,IAAQI,mBAAqB,IAErDC,QAAS,WACPT,EAAkBH,IAAiBtI,EAAK,KAAOA,KAGjD,yBAAKoH,UAAU,qDACb,8BAAOlH,GACP,8BAAOT,EAAcA,EAAY8E,OAAS,QAKlD,4BACE6C,UAAU,uBACV8B,QAAS,kBAAMpJ,MAEf,uBAAGsH,UAAU,qBACb,8CAGJ,yBAAKA,UAAU,qBACb,yBAAKA,UAAU,kCACZsB,GACD,2BACES,KAAK,OACL/B,UAAU,oBACVgC,YAAY,qBACZC,MAAOX,EAAexI,KACtBoJ,SAAU,SAAEC,GACVjJ,EAAegI,EAAc,CAC3BpI,KAAMqJ,EAAEC,OAAOH,WAKrB,4BACEjC,UAAU,8BACV8B,QAAS,kBAAM,EAAKb,iBACpBoB,SAA2B,OAAjBnB,GAAyBH,GAHrC,mBAQA,4BACEf,UAAW2B,IACT,kBACAZ,EAAc,aAAe,eAE/Be,QAAS,WACP,GAAKf,EAAc,CACjB,IAAItI,EAAuB,GAC3B,EAAKoI,kBAAkBvI,SAAU,SAAAC,GAC/BE,EAAqBD,KAArB,WAAgCD,EAAhC,SAEFW,EAAegI,EAAc,CAC3B7I,YAAaI,SAIf,EAAKoI,kBAAoB,GAC3B,EAAKG,eAAiB,gBAExBqB,SAA2B,OAAjBnB,GAEV,uBAAGlB,UAAU,sBACb,8BAAOe,EAAc,cAAgB,YAGzC,kBAAC,EAAD,CACEpD,eAAgBA,EAChBM,qBAAsB,SAAE5F,GAEtB,GADA,EAAKA,YAAcA,EACd0I,GAAe1I,EAAc,CAChC,IAAIE,EAAOF,EAAY+I,WAClB,EAAKP,kBAAkByB,QAAU/J,GAAS,GAC7C,EAAKsI,kBAAkBrI,KAAOD,KAIpCwI,YAAaA,EACbxC,MAA2B,IAApBC,OAAOC,WAAiB,GAC/BC,OAA6B,GAArBF,OAAOG,eAGnB,yBAAKqB,UAAU,qBACb,yBAAKA,UAAWyB,IAAQc,UACtB,4CACA,gGACA,oFACA,wHACA,2JACA,iR,GAtNYnG,IAAMuE,WA+OjB6B,eAhBS,SAAA3I,GACtB,MAAO,CACLlB,QAASkB,EAAM4I,cAAc7K,KAC7BsJ,aAAcrH,EAAM4I,cAAc9I,iBAIX,SAAAO,GACzB,MAAO,CACLD,WAAY,kBAAMC,EAAWwI,MAC7BrB,gBAAiB,SAAEzI,GAAF,OAAUsB,EHzOA,SAAEtB,GAC/B,OAAO,SAAAsB,GACLA,EAAWM,EAAcT,gBAAkBnB,KGuOL8J,CAAkC9J,KACxEF,aAAc,kBAAMwB,GHnOf,SAAMA,GAAN,SAAAE,EAAAC,OAAA,gDACLC,IACAJ,EAAWD,KAFN,yCGoOLf,aAAc,SAAEN,EAAIhB,GAAN,OAAgBsC,EH9NN,SAAEtB,EAAIhB,GAChC,OAAO,SAAMsC,GAAN,SAAAE,EAAAC,OAAA,gDACLC,EAA0B1B,EAAIhB,GAC9BsC,EAAWD,KAFN,sCG6NoCyI,CAA+B9J,EAAIhB,QAIjE4K,CAGX5B,GCxOW+B,EAXH,WAEV,OADAC,QAAQC,IAAM,aAAclI,gBAE1B,yBAAKqF,UAAU,OACb,kBAAC,IAAD,CAAQ8C,QAASC,IAAc,CAAEC,SAAUrI,kBACzC,kBAAC,IAAD,CAAO0C,OAAK,EAAC4F,KAAK,IAAIC,UAAWtC,OCHrBuC,QACW,cAA7B3E,OAAO4E,SAASC,UAEe,UAA7B7E,OAAO4E,SAASC,UAEhB7E,OAAO4E,SAASC,SAAS9G,MACvB,2D,oBCdS+G,cAAkB,CAC/Bb,kBCKF,IAAMc,ECFS,SAA0BC,GACvC,IAAMC,EAAmBjF,OAAOkF,sCAAwCC,IACxE,OAAOC,YACLC,EACAL,EACAC,EAAmBK,YAAkBC,ODH3BC,GAEdC,IAASC,OACP,kBAAC,IAAD,CAAUX,MAAOA,GACf,kBAAC,IAAD,KACE,kBAAC,EAAD,QAGJY,SAASC,eAAiB,SFiHtB,kBAAmBzH,WACrBA,UAAU0H,cAAcC,MAAMxH,MAAK,SAAAyH,GACjCA,EAAaC,kB","file":"static/js/main.6114145b.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"wrapper\":\"setupFaceId_wrapper__2a1wQ\",\"card_faceId\":\"setupFaceId_card_faceId__3Bm6B\",\"card_faceId_active\":\"setupFaceId_card_faceId_active__2y8xM\",\"instruct\":\"setupFaceId_instruct__v_0sy\"};","import uuid from 'uuid/v1';\n\nconst dbName = 'faceApiApp-faceIds';\n\nconst getData = () => {\n  // localStorage.clear ();\n  let data = localStorage.getItem ( dbName );\n  if ( data === null ) {\n    saveData ( [] );\n    return [];\n  }\n  else\n    return JSON.parse ( data );\n}\nconst saveData = ( data ) => {\n  localStorage.setItem ( dbName, JSON.stringify ( data ) );\n}\n\nexport const getFaceIds = async ( callback ) => {\n  let faceIds = getData ();\n  faceIds.forEach ( faceId => {\n    faceId = formatFaceIdData ( faceId );\n  } );\n  callback ( null, faceIds );\n}\n\nexport const formatFaceIdData = ( data ) => {\n  if ( data.descriptors ) {\n    let descriptors = [];\n    data.descriptors.forEach ( desc => {\n      descriptors.push ( JSON.parse ( desc ) );\n    } );\n    data.formattedDescriptors = descriptors;\n  }\n  return data;\n}\n\nexport const createFaceId = () => {\n  let faceIds = getData ();\n  let data = {\n    id: uuid (),\n    name: 'New Face ID',\n    descriptors: [],\n    date_created: new Date (),\n    date_updated: new Date ()\n  };\n  faceIds.push ( data );\n  saveData ( faceIds );\n}\n\nexport const updateFaceId = ( id, data ) => {\n  let faceIds = getData ();\n  data.date_updated = new Date ();\n  let index = -1;\n  faceIds.forEach ( ( faceId, i ) => {\n    if ( faceId.id === id )\n      index = i;\n  } );\n  if ( index >= 0 ) {\n    faceIds[ index ] = {\n      ...faceIds[ index ],\n      ...data\n    };\n    saveData ( faceIds );\n  }\n}","import autodux from 'autodux';\n\nexport const {\n  reducer,\n  actions\n} = autodux ( {\n  slice: 'faceId',\n  initial: { \n    isLoading: false,\n    error: null,\n    data: null,\n    activeDataId: null\n  },\n  actions: { \n    isLoading: ( state, isLoading ) => { \n      return { \n        ...state,\n        isLoading\n      };\n    },\n    loadSuccess: ( state, data ) => {\n      return {\n        ...state,\n        data\n      };\n    },\n    setActiveDataId: ( state, activeDataId ) => {\n      return {\n        ...state,\n        activeDataId\n      };\n    }\n  }\n} );","import * as faceIdCtrl from './faceId.controller';\nimport { actions as faceIdActions } from './faceId.redux';\n\nexport const getFaceIds = () => {\n  return dispatch => {\n    faceIdCtrl.getFaceIds ( ( err, data ) => {\n      dispatch ( faceIdActions.loadSuccess ( data ) );\n    } );\n  }\n}\n\nexport const setActiveFaceId = ( id ) => {\n  return dispatch => {\n    dispatch ( faceIdActions.setActiveDataId ( id ) );\n  }\n}\n\nexport const createFaceId = () => {\n  return async dispatch => {\n    faceIdCtrl.createFaceId ();\n    dispatch ( getFaceIds () );\n  }\n}\n\nexport const updateFaceId = ( id, data ) => {\n  return async dispatch => {\n    faceIdCtrl.updateFaceId ( id, data );\n    dispatch ( getFaceIds () );\n  }\n}","import * as faceapi from 'face-api.js';\n\n// Load models and weights\nexport async function loadModels() {\n  const MODEL_URL = process.env.PUBLIC_URL + '/models';\n  await faceapi.loadTinyFaceDetectorModel(MODEL_URL);\n  await faceapi.loadFaceLandmarkTinyModel(MODEL_URL);\n  await faceapi.loadFaceRecognitionModel(MODEL_URL);\n}\n\nexport async function getFullFaceDescription(blob, inputSize = 512) {\n  // tiny_face_detector options\n  let scoreThreshold = 0.5;\n  const OPTION = new faceapi.TinyFaceDetectorOptions({\n    inputSize,\n    scoreThreshold\n  });\n  const useTinyModel = true;\n\n  // fetch image to api\n  let img = await faceapi.fetchImage(blob);\n\n  // detect all faces and generate full description from image\n  // including landmark and descriptor of each face\n  let fullDesc = await faceapi\n    .detectAllFaces(img, OPTION)\n    .withFaceLandmarks(useTinyModel)\n    .withFaceDescriptors();\n  return fullDesc;\n}\n\nconst maxDescriptorDistance = 0.5;\nexport async function createMatcher(faceProfile) {\n  // Create labeled descriptors of member from profile\n  let members = Object.keys(faceProfile);\n  let labeledDescriptors = members.map(\n    member =>\n      new faceapi.LabeledFaceDescriptors(\n        faceProfile[member].name,\n        faceProfile[member].descriptors.map(\n          descriptor => new Float32Array(descriptor)\n        )\n      )\n  );\n\n  // Create face matcher (maximum descriptor distance is 0.5)\n  let faceMatcher = new faceapi.FaceMatcher(\n    labeledDescriptors,\n    maxDescriptorDistance\n  );\n  return faceMatcher;\n}","import React, { Component } from 'react';\nimport Webcam from 'react-webcam';\nimport { loadModels, getFullFaceDescription, createMatcher } from '../../face';\n\nconst inputSize = 160;\n\nclass FaceApiVideoInput extends Component {\n  webcam = React.createRef ();\n\n  state = {\n    fullDesc: null,\n    detections: null,\n    descriptors: null,\n    faceMatcher: null,\n    match: null,\n    facingMode: null\n  }\n\n  componentWillMount = async () => {\n    await loadModels();\n    this.setInputDevice();\n  };\n\n  setInputDevice = () => {\n    navigator.mediaDevices.enumerateDevices().then(async devices => {\n      let inputDevice = await devices.filter(\n        device => device.kind === 'videoinput'\n      );\n      if (inputDevice.length < 2) {\n        await this.setState({\n          facingMode: 'user'\n        });\n      } else {\n        await this.setState({\n          facingMode: { exact: 'environment' }\n        });\n      }\n      this.startCapture();\n    });\n  };\n\n  startCapture = () => {\n    this.interval = setInterval ( () => {\n      this.capture ();\n    }, 1000 );\n  };\n\n  _setupMatcher = async () => {\n    const {\n      matcherProfile\n    } = this.props;\n\n    if ( matcherProfile )\n      this.setState ( { \n        matcherProfile,\n        faceMatcher: await createMatcher ( matcherProfile ) \n      } );\n  }\n\n  componentDidUpdate ( prevProps ) {\n    if ( prevProps.matcherProfile !== this.state.matcherProfile )\n      this._setupMatcher ();\n  }\n\n  componentWillUnmount() {\n    clearInterval(this.interval);\n  }\n\n  capture = async () => {\n    if (this.webcam.current) {\n      await getFullFaceDescription(\n        this.webcam.current.getScreenshot(),\n        inputSize\n      ).then(fullDesc => {\n        if (fullDesc) {\n          let detections = fullDesc.map(fd => fd.detection);\n          let descriptors = fullDesc.map(fd => fd.descriptor);\n\n          if ( this.props.onReceiveDescriptors ) {\n            this.props.onReceiveDescriptors ( \n              descriptors.length > 0 ? descriptors : null\n            );\n          }\n\n          this.setState({\n            detections,\n            descriptors\n          });\n        }\n      });\n\n      if (this.state.descriptors && this.state.faceMatcher) {\n        let match = await this.state.descriptors.map(descriptor =>\n          this.state.faceMatcher.findBestMatch(descriptor)\n        );\n        if ( match && match.length > 0 ) {\n          if ( this.props.onReceiveMatch ) {\n            this.props.onReceiveMatch ( match );\n          }\n        }\n        this.setState ( { match } );\n      }\n    }\n  };\n\n  render() {\n    const {\n      width = window.innerWidth,\n      height = window.innerHeight,\n      activeProfileLabel = null\n    } = this.props;\n\n    const { detections, match, facingMode } = this.state;\n    let videoConstraints = null;\n    // let camera = '';\n    if (facingMode) {\n      videoConstraints = {\n        width: width,\n        height: height,\n        facingMode: facingMode\n      };\n      // if (facingMode === 'user') {\n      //   camera = 'Front';\n      // } else {\n      //   camera = 'Back';\n      // }\n    }\n\n    let drawBox = null;\n    if (detections) {\n      drawBox = detections.map((detection, i) => {\n        let _H = detection.box.height;\n        let _W = detection.box.width;\n        let _X = detection.box._x;\n        let _Y = detection.box._y;\n\n        let hasMatch = false;\n        if ( match && match[i] ) {\n          hasMatch = ( \n            match[i]._label !== 'unknown' \n            && match[i]._distance < 0.5 \n          );\n          if ( hasMatch && activeProfileLabel !== null ) {\n            hasMatch = ( match[i]._label === activeProfileLabel );\n          }\n        }\n        let bgColor = hasMatch ? 'green' : 'blue';\n\n        return (\n          <div key={i}>\n            <div\n              style={{\n                position: 'absolute',\n                border: 'solid',\n                borderColor: bgColor,\n                height: _H,\n                width: _W,\n                transform: `translate(${_X}px,${_Y}px)`\n              }}\n            >\n              {hasMatch ? (\n                <div\n                  className=\"d-flex justify-content-between align-items-center\"\n                  style={{\n                    backgroundColor: bgColor,\n                    border: 'solid',\n                    borderColor: bgColor,\n                    width: _W,\n                    marginTop: 0,\n                    color: '#fff',\n                    transform: `translate(-3px,${_H}px)`\n                  }}\n                >\n                  <span>{match[i]._label}</span>\n                  <span>{match[i]._distance.toFixed ( 2 )}</span>\n                </div>\n              ) : null}\n            </div>\n          </div>\n        );\n      });\n    }\n\n    return (\n      <div\n        className=\"Camera\"\n        style={{\n          display: 'flex',\n          flexDirection: 'column',\n          alignItems: 'center'\n        }}\n      >\n        {/* <p>Camera: {camera}</p> */}\n        <div\n          style={{\n            width: width,\n            height: height\n          }}\n        >\n          <div style={{ position: 'relative', width: width }}>\n            {videoConstraints ? (\n              <div style={{ position: 'absolute' }}>\n                <Webcam\n                  audio={false}\n                  width={width}\n                  height={height}\n                  ref={this.webcam}\n                  screenshotFormat=\"image/jpeg\"\n                  videoConstraints={videoConstraints}\n                />\n              </div>\n            ) : null}\n            {drawBox ? drawBox : null}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport default FaceApiVideoInput;","import React from 'react';\nimport { navigate } from '@reach/router';\nimport classnames from 'classnames';\nimport { connect } from 'react-redux';\n\nimport * as faceIdFunctions from '../../redux/faceId/faceId.function';\n\nimport classes from './setupFaceId.module.css';\n\nimport FaceApiVideoInput from '../faceApiVideoInput/faceApiVideoInput';\n\nclass SetupFaceId extends React.Component {\n  descriptors = null;\n  recordDescriptors = null;\n\n  state = {\n    booleans: {\n      isRecording: false\n    }\n  }\n\n  _toggleBoolean = ( key ) => {\n    let booleans = { ...this.state.booleans };\n    booleans[ key ] = !booleans[ key ];\n    this.setState ( {\n      booleans\n    } );\n  }\n\n  _updateFaceId = () => {\n    const {\n      faceIds,\n      activeFaceId,\n      updateFaceId\n    } = this.props;\n\n    let faceIdData = null;\n    faceIds.forEach ( faceId => {\n      if ( faceId.id === activeFaceId ) {\n        faceIdData = faceId;\n      }\n    } );\n\n    if ( faceIdData !== null && this.descriptors !== null ) {\n      updateFaceId ( activeFaceId, {\n        descriptors: [\n          ...( faceIdData.descriptors ?? [] ),\n          `[${this.descriptors.toString ()}]`\n        ]\n      } );\n    }\n  }\n\n  componentDidMount () {\n    const {\n      faceIds,\n      getFaceIds\n    } = this.props;\n\n    if ( faceIds === null )\n      getFaceIds ();\n  }\n\n  render () {\n    const {\n      booleans: {\n        isRecording\n      }\n    } = this.state;\n\n    const {\n      faceIds,\n      activeFaceId,\n      setActiveFaceId,\n      createFaceId,\n      updateFaceId\n    } = this.props;\n\n    let activeFaceData = null;\n    if ( activeFaceId && faceIds ) {\n      faceIds.forEach ( data => {\n        if ( data.id === activeFaceId ) \n          activeFaceData = data;\n      } );\n    }\n\n    let matcherProfile = null;\n    if ( faceIds !== null ) {\n      let nextMatcherProfile = {};\n      let canSetMatcherProfile = false;\n      faceIds.forEach ( ( faceId, index ) => {\n        if ( faceId.formattedDescriptors && faceId.formattedDescriptors.length > 0 ) {\n          nextMatcherProfile[ `face-${index}` ] = {\n            name: faceId.name,\n            descriptors: faceId.formattedDescriptors\n          };\n          canSetMatcherProfile = true;\n        }\n      } );\n      if ( canSetMatcherProfile )\n        matcherProfile = nextMatcherProfile;\n    }\n\n    return ( \n      <div className={classes.wrapper}>\n        {/* <button \n          className={classnames ( \n            classes.btn_back,\n            'btn btn-sm btn-link p-0 mb-2'\n          )}\n          onClick={() => {\n            setActiveFaceId ( null );\n            navigate ( '/home' );\n          }}\n        >\n          <i className=\"fas fa-home mr-2\"></i>\n          <span>Home</span>\n        </button> */}\n        <h3>Face Recognition</h3>\n        <hr />\n        <div className=\"row text-left\">\n          <div className=\"col-md-2 col-lg-2\">\n            <h5 className=\"mb-2\">Select a Face ID:</h5>\n            {faceIds && faceIds.map ( ( { \n              id, \n              name,\n              descriptors\n            }, index ) => {\n              return ( \n                <div \n                  key={index}\n                  className={classnames ( \n                    classes.card_faceId,\n                    activeFaceId === id ? classes.card_faceId_active : ''\n                  )}\n                  onClick={() => {\n                    setActiveFaceId ( activeFaceId === id ? null : id );\n                  }}\n                >\n                  <div className=\"d-flex justify-content-between align-items-center\">\n                    <span>{name}</span>\n                    <span>{descriptors ? descriptors.length : 0}</span>\n                  </div>\n                </div>\n              );\n            } )}\n            <button \n              className=\"btn btn-outline-dark\"\n              onClick={() => createFaceId ()}\n            >\n              <i className=\"fas fa-plus mr-2\"></i>\n              <span>New FaceID</span>\n            </button>\n          </div>\n          <div className=\"col-md-8 col-lg-8\">\n            <div className=\"d-flex align-items-center mb-3\">\n              {activeFaceData &&\n              <input \n                type=\"text\"\n                className=\"form-element mr-2\"\n                placeholder=\"FaceID User's Name\"\n                value={activeFaceData.name}\n                onChange={( e ) => {\n                  updateFaceId ( activeFaceId, {\n                    name: e.target.value\n                  } )\n                }}\n              />}\n\n              <button \n                className=\"btn btn-sm btn-primary mr-2\"\n                onClick={() => this._updateFaceId ()}\n                disabled={activeFaceId === null || isRecording}\n              >\n                Add Descriptors\n              </button>\n\n              <button \n                className={classnames ( \n                  'btn btn-sm mr-2',\n                  isRecording ? 'btn-danger' : 'btn-primary'\n                )}\n                onClick={() => {\n                  if ( isRecording ) {\n                    let formattedDescriptors = [];\n                    this.recordDescriptors.forEach ( desc => {\n                      formattedDescriptors.push ( `[${desc}]` );\n                    } );\n                    updateFaceId ( activeFaceId, {\n                      descriptors: formattedDescriptors\n                    } );\n                  }\n                  else\n                    this.recordDescriptors = [];\n                  this._toggleBoolean ( 'isRecording' );\n                }}\n                disabled={activeFaceId === null}\n              >\n                <i className=\"fas fa-video mr-2\"></i>\n                <span>{isRecording ? 'Stop Record' : 'Record'}</span>\n              </button>\n            </div>\n            <FaceApiVideoInput \n              matcherProfile={matcherProfile}\n              onReceiveDescriptors={( descriptors ) => {\n                this.descriptors = descriptors;\n                if ( isRecording && descriptors ) {\n                  let desc = descriptors.toString ();\n                  if ( this.recordDescriptors.indexOf ( desc ) < 0 ) {\n                    this.recordDescriptors.push ( desc );\n                  }\n                }\n              }}\n              isRecording={isRecording}\n              width={window.innerWidth * 7.8/12}\n              height={window.innerHeight * 0.8}\n            />\n          </div>\n          <div className=\"col-md-2 col-lg-2\">\n            <div className={classes.instruct}>\n              <h5>Instruction:</h5>\n              <p>1. Click \"+ New FaceID\" on the left panel to create a new FaceID.</p>\n              <p>2. Click on any of the FaceID on the list to edit it.</p>\n              <p>3. The \"Add Descriptors\" and \"Record\" button should be enabled when a FaceID is selected.</p>\n              <p>4. Click on \"Add Descriptors\" to store a copy of the descriptors data that is generated when a face is detected (green box).</p>\n              <p>5. Click on \"Record\" to start the FaceID anew, move your head around all directions slowly. All the descriptors data will be collected every second, and will be stored in your browser's local storage on \"Record\" button is toggle off.</p>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = state => {\n  return {\n    faceIds: state.faceIdReducer.data,\n    activeFaceId: state.faceIdReducer.activeDataId\n  }\n}\n\nconst mapDispatchToProps = dispatch => {\n  return {\n    getFaceIds: () => dispatch ( faceIdFunctions.getFaceIds () ),\n    setActiveFaceId: ( id ) => dispatch ( faceIdFunctions.setActiveFaceId ( id ) ),\n    createFaceId: () => dispatch ( faceIdFunctions.createFaceId () ),\n    updateFaceId: ( id, data ) => dispatch ( faceIdFunctions.updateFaceId ( id, data ) )\n  }\n}\n\nexport default connect ( \n  mapStateToProps,\n  mapDispatchToProps\n) ( SetupFaceId );","import React from 'react';\nimport { Router, Route } from 'react-router-dom';\nimport createHistory from 'history/createBrowserHistory';\n\nimport './App.css';\n// import Home from './pages/home/home';\nimport SetupFaceId from './pages/setupFaceId/setupFaceId';\n// import Error from './components/error/error';\n\n\nconst App = () => {\n  console.log ( 'PUBLIC_URL', process.env.PUBLIC_URL );\n  return (\n    <div className=\"App\">\n      <Router history={createHistory({ basename: process.env.PUBLIC_URL })}>\n        <Route exact path=\"/\" component={SetupFaceId} />\n      </Router>\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import { combineReducers } from 'redux';\n\nimport { reducer as faceIdReducer } from './faceId/faceId.redux';\n\nexport default combineReducers ( {\n  faceIdReducer\n} );","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { Provider } from 'react-redux';\nimport { HashRouter } from 'react-router-dom';\n\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport storeConfig from './redux/storeConfig';\n\nconst store = storeConfig ();\n\nReactDOM.render (\n  <Provider store={store}>\n    <HashRouter>\n      <App />\n    </HashRouter>\n  </Provider>, \n  document.getElementById ( 'root' ) \n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n","import {\n  createStore,\n  applyMiddleware,\n  compose\n} from 'redux';\nimport thunk from 'redux-thunk';\nimport rootReducer from './rootReducers';\n\nexport default function configureStore ( initialState ) {\n  const composeEnhancers = window.__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;\n  return createStore (\n    rootReducer,\n    initialState,\n    composeEnhancers ( applyMiddleware ( thunk ) )\n  );\n}"],"sourceRoot":""}